# coding: utf-8

"""
    comfyui
    No description provided (generated by Openapi JSON Schema Generator https://github.com/openapi-json-schema-tools/openapi-json-schema-generator)  # noqa: E501
    The version of the OpenAPI document: 0.0.1
    Generated by: https://github.com/openapi-json-schema-tools/openapi-json-schema-generator
"""

from __future__ import annotations
from comfy.api.shared_imports.schema_imports import *  # pyright: ignore [reportWildcardImportFromLibrary]

_0: typing_extensions.TypeAlias = schemas.StrSchema
_1: typing_extensions.TypeAlias = schemas.NumberSchema
Default: typing_extensions.TypeAlias = schemas.StrSchema
Min: typing_extensions.TypeAlias = schemas.NumberSchema
Max: typing_extensions.TypeAlias = schemas.NumberSchema
Step: typing_extensions.TypeAlias = schemas.NumberSchema
Multiline: typing_extensions.TypeAlias = schemas.BoolSchema
Properties = typing.TypedDict(
    'Properties',
    {
        "default": typing.Type[Default],
        "min": typing.Type[Min],
        "max": typing.Type[Max],
        "step": typing.Type[Step],
        "multiline": typing.Type[Multiline],
    }
)


class _2Dict(schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES]):

    __required_keys__: typing.FrozenSet[str] = frozenset({
    })
    __optional_keys__: typing.FrozenSet[str] = frozenset({
        "default",
        "min",
        "max",
        "step",
        "multiline",
    })
    
    def __new__(
        cls,
        *,
        default: typing.Union[
            str,
            schemas.Unset
        ] = schemas.unset,
        min: typing.Union[
            int,
            float,
            schemas.Unset
        ] = schemas.unset,
        max: typing.Union[
            int,
            float,
            schemas.Unset
        ] = schemas.unset,
        step: typing.Union[
            int,
            float,
            schemas.Unset
        ] = schemas.unset,
        multiline: typing.Union[
            bool,
            schemas.Unset
        ] = schemas.unset,
        configuration_: typing.Optional[schema_configuration.SchemaConfiguration] = None,
        **kwargs: schemas.INPUT_TYPES_ALL,
    ):
        arg_: typing.Dict[str, typing.Any] = {}
        for key_, val in (
            ("default", default),
            ("min", min),
            ("max", max),
            ("step", step),
            ("multiline", multiline),
        ):
            if isinstance(val, schemas.Unset):
                continue
            arg_[key_] = val
        arg_.update(kwargs)
        used_arg_ = typing.cast(_2DictInput, arg_)
        return _2.validate(used_arg_, configuration=configuration_)
    
    @staticmethod
    def from_dict_(
        arg: typing.Union[
            _2DictInput,
            _2Dict
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> _2Dict:
        return _2.validate(arg, configuration=configuration)
    
    @property
    def default(self) -> typing.Union[str, schemas.Unset]:
        val = self.get("default", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            str,
            val
        )
    
    @property
    def min(self) -> typing.Union[int, float, schemas.Unset]:
        val = self.get("min", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            typing.Union[int, float],
            val
        )
    
    @property
    def max(self) -> typing.Union[int, float, schemas.Unset]:
        val = self.get("max", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            typing.Union[int, float],
            val
        )
    
    @property
    def step(self) -> typing.Union[int, float, schemas.Unset]:
        val = self.get("step", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            typing.Union[int, float],
            val
        )
    
    @property
    def multiline(self) -> typing.Union[bool, schemas.Unset]:
        val = self.get("multiline", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            bool,
            val
        )
    
    def get_additional_property_(self, name: str) -> typing.Union[schemas.OUTPUT_BASE_TYPES, schemas.Unset]:
        schemas.raise_if_key_known(name, self.__required_keys__, self.__optional_keys__)
        return self.get(name, schemas.unset)
_2DictInput = typing.Mapping[str, schemas.INPUT_TYPES_ALL]


@dataclasses.dataclass(frozen=True)
class _2(
    schemas.Schema[_2Dict, tuple]
):
    types: typing.FrozenSet[typing.Type] = frozenset({schemas.immutabledict})
    properties: Properties = dataclasses.field(default_factory=lambda: schemas.typed_dict_to_instance(Properties)) # type: ignore
    type_to_output_cls: typing.Mapping[
        typing.Type,
        typing.Type
    ] = dataclasses.field(
        default_factory=lambda: {
            schemas.immutabledict: _2Dict
        }
    )

    @classmethod
    def validate(
        cls,
        arg: typing.Union[
            _2DictInput,
            _2Dict,
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> _2Dict:
        return super().validate_base(
            arg,
            configuration=configuration,
        )

Items2: typing_extensions.TypeAlias = schemas.StrSchema


class _3Tuple(
    typing.Tuple[
        str,
        ...
    ]
):

    def __new__(cls, arg: typing.Union[_3TupleInput, _3Tuple], configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None):
        return _3.validate(arg, configuration=configuration)
_3TupleInput = typing.Union[
    typing.List[
        str,
    ],
    typing.Tuple[
        str,
        ...
    ]
]


@dataclasses.dataclass(frozen=True)
class _3(
    schemas.Schema[schemas.immutabledict, _3Tuple]
):
    types: typing.FrozenSet[typing.Type] = frozenset({tuple})
    items: typing.Type[Items2] = dataclasses.field(default_factory=lambda: Items2) # type: ignore
    type_to_output_cls: typing.Mapping[
        typing.Type,
        typing.Type
    ] = dataclasses.field(
        default_factory=lambda: {
            tuple: _3Tuple
        }
    )

    @classmethod
    def validate(
        cls,
        arg: typing.Union[
            _3TupleInput,
            _3Tuple,
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> _3Tuple:
        return super().validate_base(
            arg,
            configuration=configuration,
        )
OneOf = typing.Tuple[
    typing.Type[_0],
    typing.Type[_1],
    typing.Type[_2],
    typing.Type[_3],
]


@dataclasses.dataclass(frozen=True)
class Items(
    schemas.AnyTypeSchema[schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES], typing.Tuple[schemas.OUTPUT_BASE_TYPES, ...]],
):
    # any type
    max_items: int = 2
    min_items: int = 1
    one_of: OneOf = dataclasses.field(default_factory=lambda: schemas.tuple_to_instance(OneOf)) # type: ignore



class AdditionalPropertiesTuple(
    typing.Tuple[
        schemas.OUTPUT_BASE_TYPES,
        ...
    ]
):

    def __new__(cls, arg: typing.Union[AdditionalPropertiesTupleInput, AdditionalPropertiesTuple], configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None):
        return AdditionalProperties.validate(arg, configuration=configuration)
AdditionalPropertiesTupleInput = typing.Union[
    typing.List[
        typing.Union[
            schemas.INPUT_TYPES_ALL,
            schemas.OUTPUT_BASE_TYPES
        ],
    ],
    typing.Tuple[
        typing.Union[
            schemas.INPUT_TYPES_ALL,
            schemas.OUTPUT_BASE_TYPES
        ],
        ...
    ]
]


@dataclasses.dataclass(frozen=True)
class AdditionalProperties(
    schemas.Schema[schemas.immutabledict, AdditionalPropertiesTuple]
):
    types: typing.FrozenSet[typing.Type] = frozenset({tuple})
    items: typing.Type[Items] = dataclasses.field(default_factory=lambda: Items) # type: ignore
    type_to_output_cls: typing.Mapping[
        typing.Type,
        typing.Type
    ] = dataclasses.field(
        default_factory=lambda: {
            tuple: AdditionalPropertiesTuple
        }
    )

    @classmethod
    def validate(
        cls,
        arg: typing.Union[
            AdditionalPropertiesTupleInput,
            AdditionalPropertiesTuple,
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> AdditionalPropertiesTuple:
        return super().validate_base(
            arg,
            configuration=configuration,
        )


class RequiredDict(schemas.immutabledict[str, AdditionalPropertiesTuple]):

    __required_keys__: typing.FrozenSet[str] = frozenset({
    })
    __optional_keys__: typing.FrozenSet[str] = frozenset({
    })
    def __new__(
        cls,
        configuration_: typing.Optional[schema_configuration.SchemaConfiguration] = None,
        **kwargs: typing.Union[
            AdditionalPropertiesTupleInput,
            AdditionalPropertiesTuple
        ],
    ):
        used_kwargs = typing.cast(RequiredDictInput, kwargs)
        return Required.validate(used_kwargs, configuration=configuration_)
    
    @staticmethod
    def from_dict_(
        arg: typing.Union[
            RequiredDictInput,
            RequiredDict
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> RequiredDict:
        return Required.validate(arg, configuration=configuration)
    
    def get_additional_property_(self, name: str) -> typing.Union[AdditionalPropertiesTuple, schemas.Unset]:
        schemas.raise_if_key_known(name, self.__required_keys__, self.__optional_keys__)
        val = self.get(name, schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            AdditionalPropertiesTuple,
            val
        )
RequiredDictInput = typing.Mapping[
    str,
    typing.Union[
        AdditionalPropertiesTupleInput,
        AdditionalPropertiesTuple
    ],
]


@dataclasses.dataclass(frozen=True)
class Required(
    schemas.Schema[RequiredDict, tuple]
):
    types: typing.FrozenSet[typing.Type] = frozenset({schemas.immutabledict})
    additional_properties: typing.Type[AdditionalProperties] = dataclasses.field(default_factory=lambda: AdditionalProperties) # type: ignore
    type_to_output_cls: typing.Mapping[
        typing.Type,
        typing.Type
    ] = dataclasses.field(
        default_factory=lambda: {
            schemas.immutabledict: RequiredDict
        }
    )

    @classmethod
    def validate(
        cls,
        arg: typing.Union[
            RequiredDictInput,
            RequiredDict,
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> RequiredDict:
        return super().validate_base(
            arg,
            configuration=configuration,
        )

AdditionalProperties2: typing_extensions.TypeAlias = schemas.StrSchema


class HiddenDict(schemas.immutabledict[str, str]):

    __required_keys__: typing.FrozenSet[str] = frozenset({
    })
    __optional_keys__: typing.FrozenSet[str] = frozenset({
    })
    def __new__(
        cls,
        configuration_: typing.Optional[schema_configuration.SchemaConfiguration] = None,
        **kwargs: str,
    ):
        used_kwargs = typing.cast(HiddenDictInput, kwargs)
        return Hidden.validate(used_kwargs, configuration=configuration_)
    
    @staticmethod
    def from_dict_(
        arg: typing.Union[
            HiddenDictInput,
            HiddenDict
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> HiddenDict:
        return Hidden.validate(arg, configuration=configuration)
    
    def get_additional_property_(self, name: str) -> typing.Union[str, schemas.Unset]:
        schemas.raise_if_key_known(name, self.__required_keys__, self.__optional_keys__)
        val = self.get(name, schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            str,
            val
        )
HiddenDictInput = typing.Mapping[
    str,
    str,
]


@dataclasses.dataclass(frozen=True)
class Hidden(
    schemas.Schema[HiddenDict, tuple]
):
    types: typing.FrozenSet[typing.Type] = frozenset({schemas.immutabledict})
    additional_properties: typing.Type[AdditionalProperties2] = dataclasses.field(default_factory=lambda: AdditionalProperties2) # type: ignore
    type_to_output_cls: typing.Mapping[
        typing.Type,
        typing.Type
    ] = dataclasses.field(
        default_factory=lambda: {
            schemas.immutabledict: HiddenDict
        }
    )

    @classmethod
    def validate(
        cls,
        arg: typing.Union[
            HiddenDictInput,
            HiddenDict,
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> HiddenDict:
        return super().validate_base(
            arg,
            configuration=configuration,
        )

Properties2 = typing.TypedDict(
    'Properties2',
    {
        "required": typing.Type[Required],
        "hidden": typing.Type[Hidden],
    }
)


class InputDict(schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES]):

    __required_keys__: typing.FrozenSet[str] = frozenset({
        "required",
    })
    __optional_keys__: typing.FrozenSet[str] = frozenset({
        "hidden",
    })
    
    def __new__(
        cls,
        *,
        required: typing.Union[
            RequiredDictInput,
            RequiredDict,
        ],
        hidden: typing.Union[
            HiddenDictInput,
            HiddenDict,
            schemas.Unset
        ] = schemas.unset,
        configuration_: typing.Optional[schema_configuration.SchemaConfiguration] = None,
        **kwargs: schemas.INPUT_TYPES_ALL,
    ):
        arg_: typing.Dict[str, typing.Any] = {
            "required": required,
        }
        for key_, val in (
            ("hidden", hidden),
        ):
            if isinstance(val, schemas.Unset):
                continue
            arg_[key_] = val
        arg_.update(kwargs)
        used_arg_ = typing.cast(InputDictInput, arg_)
        return Input.validate(used_arg_, configuration=configuration_)
    
    @staticmethod
    def from_dict_(
        arg: typing.Union[
            InputDictInput,
            InputDict
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> InputDict:
        return Input.validate(arg, configuration=configuration)
    
    @property
    def required(self) -> RequiredDict:
        return typing.cast(
            RequiredDict,
            self.__getitem__("required")
        )
    
    @property
    def hidden(self) -> typing.Union[HiddenDict, schemas.Unset]:
        val = self.get("hidden", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            HiddenDict,
            val
        )
    
    def get_additional_property_(self, name: str) -> typing.Union[schemas.OUTPUT_BASE_TYPES, schemas.Unset]:
        schemas.raise_if_key_known(name, self.__required_keys__, self.__optional_keys__)
        return self.get(name, schemas.unset)
InputDictInput = typing.Mapping[str, schemas.INPUT_TYPES_ALL]


@dataclasses.dataclass(frozen=True)
class Input(
    schemas.Schema[InputDict, tuple]
):
    types: typing.FrozenSet[typing.Type] = frozenset({schemas.immutabledict})
    required: typing.FrozenSet[str] = frozenset({
        "required",
    })
    properties: Properties2 = dataclasses.field(default_factory=lambda: schemas.typed_dict_to_instance(Properties2)) # type: ignore
    type_to_output_cls: typing.Mapping[
        typing.Type,
        typing.Type
    ] = dataclasses.field(
        default_factory=lambda: {
            schemas.immutabledict: InputDict
        }
    )

    @classmethod
    def validate(
        cls,
        arg: typing.Union[
            InputDictInput,
            InputDict,
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> InputDict:
        return super().validate_base(
            arg,
            configuration=configuration,
        )

Items3: typing_extensions.TypeAlias = schemas.StrSchema


class OutputTuple(
    typing.Tuple[
        str,
        ...
    ]
):

    def __new__(cls, arg: typing.Union[OutputTupleInput, OutputTuple], configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None):
        return Output.validate(arg, configuration=configuration)
OutputTupleInput = typing.Union[
    typing.List[
        str,
    ],
    typing.Tuple[
        str,
        ...
    ]
]


@dataclasses.dataclass(frozen=True)
class Output(
    schemas.Schema[schemas.immutabledict, OutputTuple]
):
    types: typing.FrozenSet[typing.Type] = frozenset({tuple})
    items: typing.Type[Items3] = dataclasses.field(default_factory=lambda: Items3) # type: ignore
    type_to_output_cls: typing.Mapping[
        typing.Type,
        typing.Type
    ] = dataclasses.field(
        default_factory=lambda: {
            tuple: OutputTuple
        }
    )

    @classmethod
    def validate(
        cls,
        arg: typing.Union[
            OutputTupleInput,
            OutputTuple,
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> OutputTuple:
        return super().validate_base(
            arg,
            configuration=configuration,
        )
Items4: typing_extensions.TypeAlias = schemas.BoolSchema


class OutputIsListTuple(
    typing.Tuple[
        bool,
        ...
    ]
):

    def __new__(cls, arg: typing.Union[OutputIsListTupleInput, OutputIsListTuple], configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None):
        return OutputIsList.validate(arg, configuration=configuration)
OutputIsListTupleInput = typing.Union[
    typing.List[
        bool,
    ],
    typing.Tuple[
        bool,
        ...
    ]
]


@dataclasses.dataclass(frozen=True)
class OutputIsList(
    schemas.Schema[schemas.immutabledict, OutputIsListTuple]
):
    types: typing.FrozenSet[typing.Type] = frozenset({tuple})
    items: typing.Type[Items4] = dataclasses.field(default_factory=lambda: Items4) # type: ignore
    type_to_output_cls: typing.Mapping[
        typing.Type,
        typing.Type
    ] = dataclasses.field(
        default_factory=lambda: {
            tuple: OutputIsListTuple
        }
    )

    @classmethod
    def validate(
        cls,
        arg: typing.Union[
            OutputIsListTupleInput,
            OutputIsListTuple,
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> OutputIsListTuple:
        return super().validate_base(
            arg,
            configuration=configuration,
        )
Items5: typing_extensions.TypeAlias = schemas.StrSchema


class OutputNameTuple(
    typing.Tuple[
        str,
        ...
    ]
):

    def __new__(cls, arg: typing.Union[OutputNameTupleInput, OutputNameTuple], configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None):
        return OutputName.validate(arg, configuration=configuration)
OutputNameTupleInput = typing.Union[
    typing.List[
        str,
    ],
    typing.Tuple[
        str,
        ...
    ]
]


@dataclasses.dataclass(frozen=True)
class OutputName(
    schemas.Schema[schemas.immutabledict, OutputNameTuple]
):
    types: typing.FrozenSet[typing.Type] = frozenset({tuple})
    items: typing.Type[Items5] = dataclasses.field(default_factory=lambda: Items5) # type: ignore
    type_to_output_cls: typing.Mapping[
        typing.Type,
        typing.Type
    ] = dataclasses.field(
        default_factory=lambda: {
            tuple: OutputNameTuple
        }
    )

    @classmethod
    def validate(
        cls,
        arg: typing.Union[
            OutputNameTupleInput,
            OutputNameTuple,
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> OutputNameTuple:
        return super().validate_base(
            arg,
            configuration=configuration,
        )
Name: typing_extensions.TypeAlias = schemas.StrSchema
DisplayName: typing_extensions.TypeAlias = schemas.StrSchema
Description: typing_extensions.TypeAlias = schemas.StrSchema
Category: typing_extensions.TypeAlias = schemas.StrSchema
OutputNode: typing_extensions.TypeAlias = schemas.BoolSchema
Properties3 = typing.TypedDict(
    'Properties3',
    {
        "input": typing.Type[Input],
        "output": typing.Type[Output],
        "output_is_list": typing.Type[OutputIsList],
        "output_name": typing.Type[OutputName],
        "name": typing.Type[Name],
        "display_name": typing.Type[DisplayName],
        "description": typing.Type[Description],
        "category": typing.Type[Category],
        "output_node": typing.Type[OutputNode],
    }
)


class NodeDict(schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES]):

    __required_keys__: typing.FrozenSet[str] = frozenset({
    })
    __optional_keys__: typing.FrozenSet[str] = frozenset({
        "input",
        "output",
        "output_is_list",
        "output_name",
        "name",
        "display_name",
        "description",
        "category",
        "output_node",
    })
    
    def __new__(
        cls,
        *,
        input: typing.Union[
            InputDictInput,
            InputDict,
            schemas.Unset
        ] = schemas.unset,
        output: typing.Union[
            OutputTupleInput,
            OutputTuple,
            schemas.Unset
        ] = schemas.unset,
        output_is_list: typing.Union[
            OutputIsListTupleInput,
            OutputIsListTuple,
            schemas.Unset
        ] = schemas.unset,
        output_name: typing.Union[
            OutputNameTupleInput,
            OutputNameTuple,
            schemas.Unset
        ] = schemas.unset,
        name: typing.Union[
            str,
            schemas.Unset
        ] = schemas.unset,
        display_name: typing.Union[
            str,
            schemas.Unset
        ] = schemas.unset,
        description: typing.Union[
            str,
            schemas.Unset
        ] = schemas.unset,
        category: typing.Union[
            str,
            schemas.Unset
        ] = schemas.unset,
        output_node: typing.Union[
            bool,
            schemas.Unset
        ] = schemas.unset,
        configuration_: typing.Optional[schema_configuration.SchemaConfiguration] = None,
        **kwargs: schemas.INPUT_TYPES_ALL,
    ):
        arg_: typing.Dict[str, typing.Any] = {}
        for key_, val in (
            ("input", input),
            ("output", output),
            ("output_is_list", output_is_list),
            ("output_name", output_name),
            ("name", name),
            ("display_name", display_name),
            ("description", description),
            ("category", category),
            ("output_node", output_node),
        ):
            if isinstance(val, schemas.Unset):
                continue
            arg_[key_] = val
        arg_.update(kwargs)
        used_arg_ = typing.cast(NodeDictInput, arg_)
        return Node.validate(used_arg_, configuration=configuration_)
    
    @staticmethod
    def from_dict_(
        arg: typing.Union[
            NodeDictInput,
            NodeDict
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> NodeDict:
        return Node.validate(arg, configuration=configuration)
    
    @property
    def input(self) -> typing.Union[InputDict, schemas.Unset]:
        val = self.get("input", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            InputDict,
            val
        )
    
    @property
    def output(self) -> typing.Union[OutputTuple, schemas.Unset]:
        val = self.get("output", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            OutputTuple,
            val
        )
    
    @property
    def output_is_list(self) -> typing.Union[OutputIsListTuple, schemas.Unset]:
        val = self.get("output_is_list", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            OutputIsListTuple,
            val
        )
    
    @property
    def output_name(self) -> typing.Union[OutputNameTuple, schemas.Unset]:
        val = self.get("output_name", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            OutputNameTuple,
            val
        )
    
    @property
    def name(self) -> typing.Union[str, schemas.Unset]:
        val = self.get("name", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            str,
            val
        )
    
    @property
    def display_name(self) -> typing.Union[str, schemas.Unset]:
        val = self.get("display_name", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            str,
            val
        )
    
    @property
    def description(self) -> typing.Union[str, schemas.Unset]:
        val = self.get("description", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            str,
            val
        )
    
    @property
    def category(self) -> typing.Union[str, schemas.Unset]:
        val = self.get("category", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            str,
            val
        )
    
    @property
    def output_node(self) -> typing.Union[bool, schemas.Unset]:
        val = self.get("output_node", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            bool,
            val
        )
    
    def get_additional_property_(self, name: str) -> typing.Union[schemas.OUTPUT_BASE_TYPES, schemas.Unset]:
        schemas.raise_if_key_known(name, self.__required_keys__, self.__optional_keys__)
        return self.get(name, schemas.unset)
NodeDictInput = typing.Mapping[str, schemas.INPUT_TYPES_ALL]


@dataclasses.dataclass(frozen=True)
class Node(
    schemas.Schema[NodeDict, tuple]
):
    """NOTE: This class is auto generated by OpenAPI JSON Schema Generator.
    Ref: https://github.com/openapi-json-schema-tools/openapi-json-schema-generator

    Do not edit the class manually.
    """
    types: typing.FrozenSet[typing.Type] = frozenset({schemas.immutabledict})
    properties: Properties3 = dataclasses.field(default_factory=lambda: schemas.typed_dict_to_instance(Properties3)) # type: ignore
    type_to_output_cls: typing.Mapping[
        typing.Type,
        typing.Type
    ] = dataclasses.field(
        default_factory=lambda: {
            schemas.immutabledict: NodeDict
        }
    )

    @classmethod
    def validate(
        cls,
        arg: typing.Union[
            NodeDictInput,
            NodeDict,
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> NodeDict:
        return super().validate_base(
            arg,
            configuration=configuration,
        )

