# coding: utf-8

"""
    comfyui
    No description provided (generated by Openapi JSON Schema Generator https://github.com/openapi-json-schema-tools/openapi-json-schema-generator)  # noqa: E501
    The version of the OpenAPI document: 0.0.1
    Generated by: https://github.com/openapi-json-schema-tools/openapi-json-schema-generator
"""

from __future__ import annotations
from comfy.api.shared_imports.schema_imports import *  # pyright: ignore [reportWildcardImportFromLibrary]

LastNodeId: typing_extensions.TypeAlias = schemas.IntSchema
LastLinkId: typing_extensions.TypeAlias = schemas.IntSchema
Id: typing_extensions.TypeAlias = schemas.IntSchema
Type: typing_extensions.TypeAlias = schemas.StrSchema
Items2: typing_extensions.TypeAlias = schemas.NumberSchema


class PosTuple(
    typing.Tuple[
        typing.Union[int, float],
        ...
    ]
):

    def __new__(cls, arg: typing.Union[PosTupleInput, PosTuple], configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None):
        return Pos.validate(arg, configuration=configuration)
PosTupleInput = typing.Union[
    typing.List[
        typing.Union[
            int,
            float
        ],
    ],
    typing.Tuple[
        typing.Union[
            int,
            float
        ],
        ...
    ]
]


@dataclasses.dataclass(frozen=True)
class Pos(
    schemas.Schema[schemas.immutabledict, PosTuple]
):
    types: typing.FrozenSet[typing.Type] = frozenset({tuple})
    max_items: int = 2
    min_items: int = 2
    items: typing.Type[Items2] = dataclasses.field(default_factory=lambda: Items2) # type: ignore
    type_to_output_cls: typing.Mapping[
        typing.Type,
        typing.Type
    ] = dataclasses.field(
        default_factory=lambda: {
            tuple: PosTuple
        }
    )

    @classmethod
    def validate(
        cls,
        arg: typing.Union[
            PosTupleInput,
            PosTuple,
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> PosTuple:
        return super().validate_base(
            arg,
            configuration=configuration,
        )
_0: typing_extensions.TypeAlias = schemas.NumberSchema
_1: typing_extensions.TypeAlias = schemas.NumberSchema
Properties = typing.TypedDict(
    'Properties',
    {
        "0": typing.Type[_0],
        "1": typing.Type[_1],
    }
)


class SizeDict(schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES]):

    __required_keys__: typing.FrozenSet[str] = frozenset({
    })
    __optional_keys__: typing.FrozenSet[str] = frozenset({
        "0",
        "1",
    })
    
    def __new__(
        cls,
        *,
        configuration_: typing.Optional[schema_configuration.SchemaConfiguration] = None,
        **kwargs: schemas.INPUT_TYPES_ALL,
    ):
        arg_: typing.Dict[str, typing.Any] = {}
        arg_.update(kwargs)
        used_arg_ = typing.cast(SizeDictInput, arg_)
        return Size.validate(used_arg_, configuration=configuration_)
    
    @staticmethod
    def from_dict_(
        arg: typing.Union[
            SizeDictInput,
            SizeDict
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> SizeDict:
        return Size.validate(arg, configuration=configuration)
    
    def get_additional_property_(self, name: str) -> typing.Union[schemas.OUTPUT_BASE_TYPES, schemas.Unset]:
        schemas.raise_if_key_known(name, self.__required_keys__, self.__optional_keys__)
        return self.get(name, schemas.unset)
SizeDictInput = typing.Mapping[str, schemas.INPUT_TYPES_ALL]


@dataclasses.dataclass(frozen=True)
class Size(
    schemas.Schema[SizeDict, tuple]
):
    types: typing.FrozenSet[typing.Type] = frozenset({schemas.immutabledict})
    properties: Properties = dataclasses.field(default_factory=lambda: schemas.typed_dict_to_instance(Properties)) # type: ignore
    type_to_output_cls: typing.Mapping[
        typing.Type,
        typing.Type
    ] = dataclasses.field(
        default_factory=lambda: {
            schemas.immutabledict: SizeDict
        }
    )

    @classmethod
    def validate(
        cls,
        arg: typing.Union[
            SizeDictInput,
            SizeDict,
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> SizeDict:
        return super().validate_base(
            arg,
            configuration=configuration,
        )

AdditionalProperties: typing_extensions.TypeAlias = schemas.DictSchema


class FlagsDict(schemas.immutabledict[str, schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES]]):

    __required_keys__: typing.FrozenSet[str] = frozenset({
    })
    __optional_keys__: typing.FrozenSet[str] = frozenset({
    })
    def __new__(
        cls,
        configuration_: typing.Optional[schema_configuration.SchemaConfiguration] = None,
        **kwargs: typing.Union[
            typing.Mapping[str, schemas.INPUT_TYPES_ALL],
            schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES],
        ],
    ):
        used_kwargs = typing.cast(FlagsDictInput, kwargs)
        return Flags.validate(used_kwargs, configuration=configuration_)
    
    @staticmethod
    def from_dict_(
        arg: typing.Union[
            FlagsDictInput,
            FlagsDict
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> FlagsDict:
        return Flags.validate(arg, configuration=configuration)
    
    def get_additional_property_(self, name: str) -> typing.Union[schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES], schemas.Unset]:
        schemas.raise_if_key_known(name, self.__required_keys__, self.__optional_keys__)
        val = self.get(name, schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES],
            val
        )
FlagsDictInput = typing.Mapping[
    str,
    typing.Union[
        typing.Mapping[str, schemas.INPUT_TYPES_ALL],
        schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES],
    ],
]


@dataclasses.dataclass(frozen=True)
class Flags(
    schemas.Schema[FlagsDict, tuple]
):
    types: typing.FrozenSet[typing.Type] = frozenset({schemas.immutabledict})
    additional_properties: typing.Type[AdditionalProperties] = dataclasses.field(default_factory=lambda: AdditionalProperties) # type: ignore
    type_to_output_cls: typing.Mapping[
        typing.Type,
        typing.Type
    ] = dataclasses.field(
        default_factory=lambda: {
            schemas.immutabledict: FlagsDict
        }
    )

    @classmethod
    def validate(
        cls,
        arg: typing.Union[
            FlagsDictInput,
            FlagsDict,
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> FlagsDict:
        return super().validate_base(
            arg,
            configuration=configuration,
        )

Order: typing_extensions.TypeAlias = schemas.IntSchema
Mode: typing_extensions.TypeAlias = schemas.IntSchema
Name: typing_extensions.TypeAlias = schemas.StrSchema
Type2: typing_extensions.TypeAlias = schemas.StrSchema
Link: typing_extensions.TypeAlias = schemas.IntSchema
Properties2 = typing.TypedDict(
    'Properties2',
    {
        "name": typing.Type[Name],
        "type": typing.Type[Type2],
        "link": typing.Type[Link],
    }
)


class ItemsDict(schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES]):

    __required_keys__: typing.FrozenSet[str] = frozenset({
    })
    __optional_keys__: typing.FrozenSet[str] = frozenset({
        "name",
        "type",
        "link",
    })
    
    def __new__(
        cls,
        *,
        name: typing.Union[
            str,
            schemas.Unset
        ] = schemas.unset,
        type: typing.Union[
            str,
            schemas.Unset
        ] = schemas.unset,
        link: typing.Union[
            int,
            schemas.Unset
        ] = schemas.unset,
        configuration_: typing.Optional[schema_configuration.SchemaConfiguration] = None,
        **kwargs: schemas.INPUT_TYPES_ALL,
    ):
        arg_: typing.Dict[str, typing.Any] = {}
        for key_, val in (
            ("name", name),
            ("type", type),
            ("link", link),
        ):
            if isinstance(val, schemas.Unset):
                continue
            arg_[key_] = val
        arg_.update(kwargs)
        used_arg_ = typing.cast(ItemsDictInput, arg_)
        return Items3.validate(used_arg_, configuration=configuration_)
    
    @staticmethod
    def from_dict_(
        arg: typing.Union[
            ItemsDictInput,
            ItemsDict
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> ItemsDict:
        return Items3.validate(arg, configuration=configuration)
    
    @property
    def name(self) -> typing.Union[str, schemas.Unset]:
        val = self.get("name", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            str,
            val
        )
    
    @property
    def type(self) -> typing.Union[str, schemas.Unset]:
        val = self.get("type", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            str,
            val
        )
    
    @property
    def link(self) -> typing.Union[int, schemas.Unset]:
        val = self.get("link", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            int,
            val
        )
    
    def get_additional_property_(self, name: str) -> typing.Union[schemas.OUTPUT_BASE_TYPES, schemas.Unset]:
        schemas.raise_if_key_known(name, self.__required_keys__, self.__optional_keys__)
        return self.get(name, schemas.unset)
ItemsDictInput = typing.Mapping[str, schemas.INPUT_TYPES_ALL]


@dataclasses.dataclass(frozen=True)
class Items3(
    schemas.Schema[ItemsDict, tuple]
):
    types: typing.FrozenSet[typing.Type] = frozenset({schemas.immutabledict})
    properties: Properties2 = dataclasses.field(default_factory=lambda: schemas.typed_dict_to_instance(Properties2)) # type: ignore
    type_to_output_cls: typing.Mapping[
        typing.Type,
        typing.Type
    ] = dataclasses.field(
        default_factory=lambda: {
            schemas.immutabledict: ItemsDict
        }
    )

    @classmethod
    def validate(
        cls,
        arg: typing.Union[
            ItemsDictInput,
            ItemsDict,
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> ItemsDict:
        return super().validate_base(
            arg,
            configuration=configuration,
        )



class InputsTuple(
    typing.Tuple[
        ItemsDict,
        ...
    ]
):

    def __new__(cls, arg: typing.Union[InputsTupleInput, InputsTuple], configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None):
        return Inputs.validate(arg, configuration=configuration)
InputsTupleInput = typing.Union[
    typing.List[
        typing.Union[
            ItemsDictInput,
            ItemsDict,
        ],
    ],
    typing.Tuple[
        typing.Union[
            ItemsDictInput,
            ItemsDict,
        ],
        ...
    ]
]


@dataclasses.dataclass(frozen=True)
class Inputs(
    schemas.Schema[schemas.immutabledict, InputsTuple]
):
    types: typing.FrozenSet[typing.Type] = frozenset({tuple})
    items: typing.Type[Items3] = dataclasses.field(default_factory=lambda: Items3) # type: ignore
    type_to_output_cls: typing.Mapping[
        typing.Type,
        typing.Type
    ] = dataclasses.field(
        default_factory=lambda: {
            tuple: InputsTuple
        }
    )

    @classmethod
    def validate(
        cls,
        arg: typing.Union[
            InputsTupleInput,
            InputsTuple,
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> InputsTuple:
        return super().validate_base(
            arg,
            configuration=configuration,
        )
Name2: typing_extensions.TypeAlias = schemas.StrSchema
Type3: typing_extensions.TypeAlias = schemas.StrSchema
Items5: typing_extensions.TypeAlias = schemas.IntSchema


class LinksTuple(
    typing.Tuple[
        int,
        ...
    ]
):

    def __new__(cls, arg: typing.Union[LinksTupleInput, LinksTuple], configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None):
        return Links.validate(arg, configuration=configuration)
LinksTupleInput = typing.Union[
    typing.List[
        int,
    ],
    typing.Tuple[
        int,
        ...
    ]
]


@dataclasses.dataclass(frozen=True)
class Links(
    schemas.Schema[schemas.immutabledict, LinksTuple]
):
    types: typing.FrozenSet[typing.Type] = frozenset({tuple})
    items: typing.Type[Items5] = dataclasses.field(default_factory=lambda: Items5) # type: ignore
    type_to_output_cls: typing.Mapping[
        typing.Type,
        typing.Type
    ] = dataclasses.field(
        default_factory=lambda: {
            tuple: LinksTuple
        }
    )

    @classmethod
    def validate(
        cls,
        arg: typing.Union[
            LinksTupleInput,
            LinksTuple,
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> LinksTuple:
        return super().validate_base(
            arg,
            configuration=configuration,
        )
SlotIndex: typing_extensions.TypeAlias = schemas.IntSchema
Properties3 = typing.TypedDict(
    'Properties3',
    {
        "name": typing.Type[Name2],
        "type": typing.Type[Type3],
        "links": typing.Type[Links],
        "slot_index": typing.Type[SlotIndex],
    }
)


class ItemsDict2(schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES]):

    __required_keys__: typing.FrozenSet[str] = frozenset({
    })
    __optional_keys__: typing.FrozenSet[str] = frozenset({
        "name",
        "type",
        "links",
        "slot_index",
    })
    
    def __new__(
        cls,
        *,
        name: typing.Union[
            str,
            schemas.Unset
        ] = schemas.unset,
        type: typing.Union[
            str,
            schemas.Unset
        ] = schemas.unset,
        links: typing.Union[
            LinksTupleInput,
            LinksTuple,
            schemas.Unset
        ] = schemas.unset,
        slot_index: typing.Union[
            int,
            schemas.Unset
        ] = schemas.unset,
        configuration_: typing.Optional[schema_configuration.SchemaConfiguration] = None,
        **kwargs: schemas.INPUT_TYPES_ALL,
    ):
        arg_: typing.Dict[str, typing.Any] = {}
        for key_, val in (
            ("name", name),
            ("type", type),
            ("links", links),
            ("slot_index", slot_index),
        ):
            if isinstance(val, schemas.Unset):
                continue
            arg_[key_] = val
        arg_.update(kwargs)
        used_arg_ = typing.cast(ItemsDictInput2, arg_)
        return Items4.validate(used_arg_, configuration=configuration_)
    
    @staticmethod
    def from_dict_(
        arg: typing.Union[
            ItemsDictInput2,
            ItemsDict2
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> ItemsDict2:
        return Items4.validate(arg, configuration=configuration)
    
    @property
    def name(self) -> typing.Union[str, schemas.Unset]:
        val = self.get("name", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            str,
            val
        )
    
    @property
    def type(self) -> typing.Union[str, schemas.Unset]:
        val = self.get("type", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            str,
            val
        )
    
    @property
    def links(self) -> typing.Union[LinksTuple, schemas.Unset]:
        val = self.get("links", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            LinksTuple,
            val
        )
    
    @property
    def slot_index(self) -> typing.Union[int, schemas.Unset]:
        val = self.get("slot_index", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            int,
            val
        )
    
    def get_additional_property_(self, name: str) -> typing.Union[schemas.OUTPUT_BASE_TYPES, schemas.Unset]:
        schemas.raise_if_key_known(name, self.__required_keys__, self.__optional_keys__)
        return self.get(name, schemas.unset)
ItemsDictInput2 = typing.Mapping[str, schemas.INPUT_TYPES_ALL]


@dataclasses.dataclass(frozen=True)
class Items4(
    schemas.Schema[ItemsDict2, tuple]
):
    types: typing.FrozenSet[typing.Type] = frozenset({schemas.immutabledict})
    properties: Properties3 = dataclasses.field(default_factory=lambda: schemas.typed_dict_to_instance(Properties3)) # type: ignore
    type_to_output_cls: typing.Mapping[
        typing.Type,
        typing.Type
    ] = dataclasses.field(
        default_factory=lambda: {
            schemas.immutabledict: ItemsDict2
        }
    )

    @classmethod
    def validate(
        cls,
        arg: typing.Union[
            ItemsDictInput2,
            ItemsDict2,
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> ItemsDict2:
        return super().validate_base(
            arg,
            configuration=configuration,
        )



class OutputsTuple(
    typing.Tuple[
        ItemsDict2,
        ...
    ]
):

    def __new__(cls, arg: typing.Union[OutputsTupleInput, OutputsTuple], configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None):
        return Outputs.validate(arg, configuration=configuration)
OutputsTupleInput = typing.Union[
    typing.List[
        typing.Union[
            ItemsDictInput2,
            ItemsDict2,
        ],
    ],
    typing.Tuple[
        typing.Union[
            ItemsDictInput2,
            ItemsDict2,
        ],
        ...
    ]
]


@dataclasses.dataclass(frozen=True)
class Outputs(
    schemas.Schema[schemas.immutabledict, OutputsTuple]
):
    types: typing.FrozenSet[typing.Type] = frozenset({tuple})
    items: typing.Type[Items4] = dataclasses.field(default_factory=lambda: Items4) # type: ignore
    type_to_output_cls: typing.Mapping[
        typing.Type,
        typing.Type
    ] = dataclasses.field(
        default_factory=lambda: {
            tuple: OutputsTuple
        }
    )

    @classmethod
    def validate(
        cls,
        arg: typing.Union[
            OutputsTupleInput,
            OutputsTuple,
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> OutputsTuple:
        return super().validate_base(
            arg,
            configuration=configuration,
        )
Properties4: typing_extensions.TypeAlias = schemas.DictSchema
Items6: typing_extensions.TypeAlias = schemas.StrSchema


class WidgetsValuesTuple(
    typing.Tuple[
        str,
        ...
    ]
):

    def __new__(cls, arg: typing.Union[WidgetsValuesTupleInput, WidgetsValuesTuple], configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None):
        return WidgetsValues.validate(arg, configuration=configuration)
WidgetsValuesTupleInput = typing.Union[
    typing.List[
        str,
    ],
    typing.Tuple[
        str,
        ...
    ]
]


@dataclasses.dataclass(frozen=True)
class WidgetsValues(
    schemas.Schema[schemas.immutabledict, WidgetsValuesTuple]
):
    types: typing.FrozenSet[typing.Type] = frozenset({tuple})
    items: typing.Type[Items6] = dataclasses.field(default_factory=lambda: Items6) # type: ignore
    type_to_output_cls: typing.Mapping[
        typing.Type,
        typing.Type
    ] = dataclasses.field(
        default_factory=lambda: {
            tuple: WidgetsValuesTuple
        }
    )

    @classmethod
    def validate(
        cls,
        arg: typing.Union[
            WidgetsValuesTupleInput,
            WidgetsValuesTuple,
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> WidgetsValuesTuple:
        return super().validate_base(
            arg,
            configuration=configuration,
        )
Properties5 = typing.TypedDict(
    'Properties5',
    {
        "id": typing.Type[Id],
        "type": typing.Type[Type],
        "pos": typing.Type[Pos],
        "size": typing.Type[Size],
        "flags": typing.Type[Flags],
        "order": typing.Type[Order],
        "mode": typing.Type[Mode],
        "inputs": typing.Type[Inputs],
        "outputs": typing.Type[Outputs],
        "properties": typing.Type[Properties4],
        "widgets_values": typing.Type[WidgetsValues],
    }
)


class ItemsDict3(schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES]):

    __required_keys__: typing.FrozenSet[str] = frozenset({
    })
    __optional_keys__: typing.FrozenSet[str] = frozenset({
        "id",
        "type",
        "pos",
        "size",
        "flags",
        "order",
        "mode",
        "inputs",
        "outputs",
        "properties",
        "widgets_values",
    })
    
    def __new__(
        cls,
        *,
        id: typing.Union[
            int,
            schemas.Unset
        ] = schemas.unset,
        type: typing.Union[
            str,
            schemas.Unset
        ] = schemas.unset,
        pos: typing.Union[
            PosTupleInput,
            PosTuple,
            schemas.Unset
        ] = schemas.unset,
        size: typing.Union[
            SizeDictInput,
            SizeDict,
            schemas.Unset
        ] = schemas.unset,
        flags: typing.Union[
            FlagsDictInput,
            FlagsDict,
            schemas.Unset
        ] = schemas.unset,
        order: typing.Union[
            int,
            schemas.Unset
        ] = schemas.unset,
        mode: typing.Union[
            int,
            schemas.Unset
        ] = schemas.unset,
        inputs: typing.Union[
            InputsTupleInput,
            InputsTuple,
            schemas.Unset
        ] = schemas.unset,
        outputs: typing.Union[
            OutputsTupleInput,
            OutputsTuple,
            schemas.Unset
        ] = schemas.unset,
        properties: typing.Union[
            typing.Mapping[str, schemas.INPUT_TYPES_ALL],
            schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES],
            schemas.Unset
        ] = schemas.unset,
        widgets_values: typing.Union[
            WidgetsValuesTupleInput,
            WidgetsValuesTuple,
            schemas.Unset
        ] = schemas.unset,
        configuration_: typing.Optional[schema_configuration.SchemaConfiguration] = None,
        **kwargs: schemas.INPUT_TYPES_ALL,
    ):
        arg_: typing.Dict[str, typing.Any] = {}
        for key_, val in (
            ("id", id),
            ("type", type),
            ("pos", pos),
            ("size", size),
            ("flags", flags),
            ("order", order),
            ("mode", mode),
            ("inputs", inputs),
            ("outputs", outputs),
            ("properties", properties),
            ("widgets_values", widgets_values),
        ):
            if isinstance(val, schemas.Unset):
                continue
            arg_[key_] = val
        arg_.update(kwargs)
        used_arg_ = typing.cast(ItemsDictInput3, arg_)
        return Items.validate(used_arg_, configuration=configuration_)
    
    @staticmethod
    def from_dict_(
        arg: typing.Union[
            ItemsDictInput3,
            ItemsDict3
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> ItemsDict3:
        return Items.validate(arg, configuration=configuration)
    
    @property
    def id(self) -> typing.Union[int, schemas.Unset]:
        val = self.get("id", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            int,
            val
        )
    
    @property
    def type(self) -> typing.Union[str, schemas.Unset]:
        val = self.get("type", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            str,
            val
        )
    
    @property
    def pos(self) -> typing.Union[PosTuple, schemas.Unset]:
        val = self.get("pos", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            PosTuple,
            val
        )
    
    @property
    def size(self) -> typing.Union[SizeDict, schemas.Unset]:
        val = self.get("size", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            SizeDict,
            val
        )
    
    @property
    def flags(self) -> typing.Union[FlagsDict, schemas.Unset]:
        val = self.get("flags", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            FlagsDict,
            val
        )
    
    @property
    def order(self) -> typing.Union[int, schemas.Unset]:
        val = self.get("order", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            int,
            val
        )
    
    @property
    def mode(self) -> typing.Union[int, schemas.Unset]:
        val = self.get("mode", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            int,
            val
        )
    
    @property
    def inputs(self) -> typing.Union[InputsTuple, schemas.Unset]:
        val = self.get("inputs", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            InputsTuple,
            val
        )
    
    @property
    def outputs(self) -> typing.Union[OutputsTuple, schemas.Unset]:
        val = self.get("outputs", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            OutputsTuple,
            val
        )
    
    @property
    def properties(self) -> typing.Union[schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES], schemas.Unset]:
        val = self.get("properties", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES],
            val
        )
    
    @property
    def widgets_values(self) -> typing.Union[WidgetsValuesTuple, schemas.Unset]:
        val = self.get("widgets_values", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            WidgetsValuesTuple,
            val
        )
    
    def get_additional_property_(self, name: str) -> typing.Union[schemas.OUTPUT_BASE_TYPES, schemas.Unset]:
        schemas.raise_if_key_known(name, self.__required_keys__, self.__optional_keys__)
        return self.get(name, schemas.unset)
ItemsDictInput3 = typing.Mapping[str, schemas.INPUT_TYPES_ALL]


@dataclasses.dataclass(frozen=True)
class Items(
    schemas.Schema[ItemsDict3, tuple]
):
    types: typing.FrozenSet[typing.Type] = frozenset({schemas.immutabledict})
    properties: Properties5 = dataclasses.field(default_factory=lambda: schemas.typed_dict_to_instance(Properties5)) # type: ignore
    type_to_output_cls: typing.Mapping[
        typing.Type,
        typing.Type
    ] = dataclasses.field(
        default_factory=lambda: {
            schemas.immutabledict: ItemsDict3
        }
    )

    @classmethod
    def validate(
        cls,
        arg: typing.Union[
            ItemsDictInput3,
            ItemsDict3,
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> ItemsDict3:
        return super().validate_base(
            arg,
            configuration=configuration,
        )



class NodesTuple(
    typing.Tuple[
        ItemsDict3,
        ...
    ]
):

    def __new__(cls, arg: typing.Union[NodesTupleInput, NodesTuple], configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None):
        return Nodes.validate(arg, configuration=configuration)
NodesTupleInput = typing.Union[
    typing.List[
        typing.Union[
            ItemsDictInput3,
            ItemsDict3,
        ],
    ],
    typing.Tuple[
        typing.Union[
            ItemsDictInput3,
            ItemsDict3,
        ],
        ...
    ]
]


@dataclasses.dataclass(frozen=True)
class Nodes(
    schemas.Schema[schemas.immutabledict, NodesTuple]
):
    types: typing.FrozenSet[typing.Type] = frozenset({tuple})
    items: typing.Type[Items] = dataclasses.field(default_factory=lambda: Items) # type: ignore
    type_to_output_cls: typing.Mapping[
        typing.Type,
        typing.Type
    ] = dataclasses.field(
        default_factory=lambda: {
            tuple: NodesTuple
        }
    )

    @classmethod
    def validate(
        cls,
        arg: typing.Union[
            NodesTupleInput,
            NodesTuple,
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> NodesTuple:
        return super().validate_base(
            arg,
            configuration=configuration,
        )
_02: typing_extensions.TypeAlias = schemas.IntSchema
_12: typing_extensions.TypeAlias = schemas.StrSchema
OneOf = typing.Tuple[
    typing.Type[_02],
    typing.Type[_12],
]


@dataclasses.dataclass(frozen=True)
class Items8(
    schemas.AnyTypeSchema[schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES], typing.Tuple[schemas.OUTPUT_BASE_TYPES, ...]],
):
    # any type
    max_items: int = 6
    min_items: int = 6
    one_of: OneOf = dataclasses.field(default_factory=lambda: schemas.tuple_to_instance(OneOf)) # type: ignore



class ItemsTuple(
    typing.Tuple[
        schemas.OUTPUT_BASE_TYPES,
        ...
    ]
):

    def __new__(cls, arg: typing.Union[ItemsTupleInput, ItemsTuple], configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None):
        return Items7.validate(arg, configuration=configuration)
ItemsTupleInput = typing.Union[
    typing.List[
        typing.Union[
            schemas.INPUT_TYPES_ALL,
            schemas.OUTPUT_BASE_TYPES
        ],
    ],
    typing.Tuple[
        typing.Union[
            schemas.INPUT_TYPES_ALL,
            schemas.OUTPUT_BASE_TYPES
        ],
        ...
    ]
]


@dataclasses.dataclass(frozen=True)
class Items7(
    schemas.Schema[schemas.immutabledict, ItemsTuple]
):
    types: typing.FrozenSet[typing.Type] = frozenset({tuple})
    items: typing.Type[Items8] = dataclasses.field(default_factory=lambda: Items8) # type: ignore
    type_to_output_cls: typing.Mapping[
        typing.Type,
        typing.Type
    ] = dataclasses.field(
        default_factory=lambda: {
            tuple: ItemsTuple
        }
    )

    @classmethod
    def validate(
        cls,
        arg: typing.Union[
            ItemsTupleInput,
            ItemsTuple,
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> ItemsTuple:
        return super().validate_base(
            arg,
            configuration=configuration,
        )


class LinksTuple2(
    typing.Tuple[
        ItemsTuple,
        ...
    ]
):

    def __new__(cls, arg: typing.Union[LinksTupleInput2, LinksTuple2], configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None):
        return Links2.validate(arg, configuration=configuration)
LinksTupleInput2 = typing.Union[
    typing.List[
        typing.Union[
            ItemsTupleInput,
            ItemsTuple
        ],
    ],
    typing.Tuple[
        typing.Union[
            ItemsTupleInput,
            ItemsTuple
        ],
        ...
    ]
]


@dataclasses.dataclass(frozen=True)
class Links2(
    schemas.Schema[schemas.immutabledict, LinksTuple2]
):
    types: typing.FrozenSet[typing.Type] = frozenset({tuple})
    items: typing.Type[Items7] = dataclasses.field(default_factory=lambda: Items7) # type: ignore
    type_to_output_cls: typing.Mapping[
        typing.Type,
        typing.Type
    ] = dataclasses.field(
        default_factory=lambda: {
            tuple: LinksTuple2
        }
    )

    @classmethod
    def validate(
        cls,
        arg: typing.Union[
            LinksTupleInput2,
            LinksTuple2,
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> LinksTuple2:
        return super().validate_base(
            arg,
            configuration=configuration,
        )
Items9: typing_extensions.TypeAlias = schemas.DictSchema


class GroupsTuple(
    typing.Tuple[
        schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES],
        ...
    ]
):

    def __new__(cls, arg: typing.Union[GroupsTupleInput, GroupsTuple], configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None):
        return Groups.validate(arg, configuration=configuration)
GroupsTupleInput = typing.Union[
    typing.List[
        typing.Union[
            typing.Mapping[str, schemas.INPUT_TYPES_ALL],
            schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES],
        ],
    ],
    typing.Tuple[
        typing.Union[
            typing.Mapping[str, schemas.INPUT_TYPES_ALL],
            schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES],
        ],
        ...
    ]
]


@dataclasses.dataclass(frozen=True)
class Groups(
    schemas.Schema[schemas.immutabledict, GroupsTuple]
):
    types: typing.FrozenSet[typing.Type] = frozenset({tuple})
    items: typing.Type[Items9] = dataclasses.field(default_factory=lambda: Items9) # type: ignore
    type_to_output_cls: typing.Mapping[
        typing.Type,
        typing.Type
    ] = dataclasses.field(
        default_factory=lambda: {
            tuple: GroupsTuple
        }
    )

    @classmethod
    def validate(
        cls,
        arg: typing.Union[
            GroupsTupleInput,
            GroupsTuple,
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> GroupsTuple:
        return super().validate_base(
            arg,
            configuration=configuration,
        )
Config: typing_extensions.TypeAlias = schemas.DictSchema
Extra: typing_extensions.TypeAlias = schemas.DictSchema
Version: typing_extensions.TypeAlias = schemas.NumberSchema
Properties6 = typing.TypedDict(
    'Properties6',
    {
        "last_node_id": typing.Type[LastNodeId],
        "last_link_id": typing.Type[LastLinkId],
        "nodes": typing.Type[Nodes],
        "links": typing.Type[Links2],
        "groups": typing.Type[Groups],
        "config": typing.Type[Config],
        "extra": typing.Type[Extra],
        "version": typing.Type[Version],
    }
)


class WorkflowDict(schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES]):

    __required_keys__: typing.FrozenSet[str] = frozenset({
    })
    __optional_keys__: typing.FrozenSet[str] = frozenset({
        "last_node_id",
        "last_link_id",
        "nodes",
        "links",
        "groups",
        "config",
        "extra",
        "version",
    })
    
    def __new__(
        cls,
        *,
        last_node_id: typing.Union[
            int,
            schemas.Unset
        ] = schemas.unset,
        last_link_id: typing.Union[
            int,
            schemas.Unset
        ] = schemas.unset,
        nodes: typing.Union[
            NodesTupleInput,
            NodesTuple,
            schemas.Unset
        ] = schemas.unset,
        links: typing.Union[
            LinksTupleInput2,
            LinksTuple2,
            schemas.Unset
        ] = schemas.unset,
        groups: typing.Union[
            GroupsTupleInput,
            GroupsTuple,
            schemas.Unset
        ] = schemas.unset,
        config: typing.Union[
            typing.Mapping[str, schemas.INPUT_TYPES_ALL],
            schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES],
            schemas.Unset
        ] = schemas.unset,
        extra: typing.Union[
            typing.Mapping[str, schemas.INPUT_TYPES_ALL],
            schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES],
            schemas.Unset
        ] = schemas.unset,
        version: typing.Union[
            int,
            float,
            schemas.Unset
        ] = schemas.unset,
        configuration_: typing.Optional[schema_configuration.SchemaConfiguration] = None,
        **kwargs: schemas.INPUT_TYPES_ALL,
    ):
        arg_: typing.Dict[str, typing.Any] = {}
        for key_, val in (
            ("last_node_id", last_node_id),
            ("last_link_id", last_link_id),
            ("nodes", nodes),
            ("links", links),
            ("groups", groups),
            ("config", config),
            ("extra", extra),
            ("version", version),
        ):
            if isinstance(val, schemas.Unset):
                continue
            arg_[key_] = val
        arg_.update(kwargs)
        used_arg_ = typing.cast(WorkflowDictInput, arg_)
        return Workflow.validate(used_arg_, configuration=configuration_)
    
    @staticmethod
    def from_dict_(
        arg: typing.Union[
            WorkflowDictInput,
            WorkflowDict
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> WorkflowDict:
        return Workflow.validate(arg, configuration=configuration)
    
    @property
    def last_node_id(self) -> typing.Union[int, schemas.Unset]:
        val = self.get("last_node_id", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            int,
            val
        )
    
    @property
    def last_link_id(self) -> typing.Union[int, schemas.Unset]:
        val = self.get("last_link_id", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            int,
            val
        )
    
    @property
    def nodes(self) -> typing.Union[NodesTuple, schemas.Unset]:
        val = self.get("nodes", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            NodesTuple,
            val
        )
    
    @property
    def links(self) -> typing.Union[LinksTuple2, schemas.Unset]:
        val = self.get("links", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            LinksTuple2,
            val
        )
    
    @property
    def groups(self) -> typing.Union[GroupsTuple, schemas.Unset]:
        val = self.get("groups", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            GroupsTuple,
            val
        )
    
    @property
    def config(self) -> typing.Union[schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES], schemas.Unset]:
        val = self.get("config", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES],
            val
        )
    
    @property
    def extra(self) -> typing.Union[schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES], schemas.Unset]:
        val = self.get("extra", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES],
            val
        )
    
    @property
    def version(self) -> typing.Union[int, float, schemas.Unset]:
        val = self.get("version", schemas.unset)
        if isinstance(val, schemas.Unset):
            return val
        return typing.cast(
            typing.Union[int, float],
            val
        )
    
    def get_additional_property_(self, name: str) -> typing.Union[schemas.OUTPUT_BASE_TYPES, schemas.Unset]:
        schemas.raise_if_key_known(name, self.__required_keys__, self.__optional_keys__)
        return self.get(name, schemas.unset)
WorkflowDictInput = typing.Mapping[str, schemas.INPUT_TYPES_ALL]


@dataclasses.dataclass(frozen=True)
class Workflow(
    schemas.Schema[WorkflowDict, tuple]
):
    """NOTE: This class is auto generated by OpenAPI JSON Schema Generator.
    Ref: https://github.com/openapi-json-schema-tools/openapi-json-schema-generator

    Do not edit the class manually.
    """
    types: typing.FrozenSet[typing.Type] = frozenset({schemas.immutabledict})
    properties: Properties6 = dataclasses.field(default_factory=lambda: schemas.typed_dict_to_instance(Properties6)) # type: ignore
    type_to_output_cls: typing.Mapping[
        typing.Type,
        typing.Type
    ] = dataclasses.field(
        default_factory=lambda: {
            schemas.immutabledict: WorkflowDict
        }
    )

    @classmethod
    def validate(
        cls,
        arg: typing.Union[
            WorkflowDictInput,
            WorkflowDict,
        ],
        configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    ) -> WorkflowDict:
        return super().validate_base(
            arg,
            configuration=configuration,
        )

